'use client';

import { useState, useEffect, useCallback } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Sparkles, ChevronDown, ChevronUp } from 'lucide-react';
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from '@/components/ui/collapsible';
import { ConversationPreview } from './conversation-preview';
import { useI18n } from '@/hooks/useI18n';
import type { User } from '@/types';
import type { ConversationType } from '@meeshy/shared/types';

// Hooks personnalisés
import { useUserSelection, useUserSearch } from '@/hooks/use-user-search';
import { useCommunitySearch } from '@/hooks/use-community-search';
import { useIdentifierValidation } from '@/hooks/use-identifier-validation';
import { useConversationCreation } from '@/hooks/use-conversation-creation';

// Steps components (lazy loaded)
import {
  MemberSelectionStep,
  ConversationTypeStep,
  ConversationDetailsStep,
  CommunitySelectionStep
} from './steps';

interface CreateConversationModalProps {
  isOpen: boolean;
  onClose: () => void;
  currentUser: User;
  onConversationCreated: (conversationId: string, conversationData?: any) => void;
}

/**
 * Modal de création de conversation refactorisée
 * Utilise des hooks personnalisés pour la logique et des composants séparés pour l'UI
 */
export function CreateConversationModal({
  isOpen,
  onClose,
  currentUser,
  onConversationCreated
}: CreateConversationModalProps) {
  const { t } = useI18n('modals');

  // États locaux pour l'UI
  const [searchQuery, setSearchQuery] = useState('');
  const [title, setTitle] = useState('');
  const [customIdentifier, setCustomIdentifier] = useState('');
  const [conversationType, setConversationType] = useState<ConversationType>('direct');
  const [showCommunitySection, setShowCommunitySection] = useState(false);
  const [isPreviewOpen, setIsPreviewOpen] = useState(false);
  const [communitySearchQuery, setCommunitySearchQuery] = useState('');
  const [selectedCommunity, setSelectedCommunity] = useState<string>('');

  // Hooks personnalisés pour la logique métier
  const { selectedUsers, toggleUserSelection, clearSelection } = useUserSelection();
  const { availableUsers, isLoading, searchUsers } = useUserSearch(currentUser.id, selectedUsers);
  const { communities, isLoadingCommunities, loadCommunities } = useCommunitySearch();
  const {
    identifierAvailable,
    isCheckingIdentifier,
    validateIdentifierFormat,
    generateIdentifierFromTitle
  } = useIdentifierValidation(customIdentifier, conversationType);
  const { isCreating, createConversation: createConversationFn } = useConversationCreation();

  // Recherche d'utilisateurs avec debounce
  useEffect(() => {
    if (isOpen && searchQuery.trim()) {
      const timer = setTimeout(() => {
        searchUsers(searchQuery);
      }, 300);
      return () => clearTimeout(timer);
    }
  }, [isOpen, searchQuery, searchUsers]);

  // Chargement des communautés
  useEffect(() => {
    if (isOpen) {
      loadCommunities();
    }
  }, [isOpen, loadCommunities]);

  // Recherche de communautés avec debounce
  useEffect(() => {
    if (communitySearchQuery.length >= 2) {
      const timer = setTimeout(() => {
        loadCommunities(communitySearchQuery);
      }, 300);
      return () => clearTimeout(timer);
    } else if (communitySearchQuery.length === 0) {
      loadCommunities();
    }
  }, [communitySearchQuery, loadCommunities]);

  // Auto-génération du titre basé sur les utilisateurs sélectionnés
  useEffect(() => {
    if (selectedUsers.length > 0 && !title) {
      const getUserDisplayName = (user: User): string => {
        return user.displayName || user.username || user.firstName || user.lastName || 'Unknown User';
      };

      let autoTitle = '';
      if (selectedUsers.length === 1) {
        autoTitle = t('createConversationModal.autoGeneratedTitles.directWithUser', {
          username: getUserDisplayName(selectedUsers[0])
        });
      } else if (selectedUsers.length === 2) {
        const names = selectedUsers.map(u => getUserDisplayName(u));
        autoTitle = t('createConversationModal.autoGeneratedTitles.betweenTwoUsers', {
          user1: names[0],
          user2: names[1]
        });
      } else {
        const firstNames = selectedUsers.slice(0, 2).map(u => getUserDisplayName(u));
        const remainingCount = selectedUsers.length - 2;
        if (remainingCount > 0) {
          autoTitle = t('createConversationModal.autoGeneratedTitles.groupWithMultiple', {
            user1: firstNames[0],
            user2: firstNames[1],
            count: remainingCount,
            plural: remainingCount > 1 ? 's' : ''
          });
        } else {
          autoTitle = t('createConversationModal.autoGeneratedTitles.groupWithTwo', {
            user1: firstNames[0],
            user2: firstNames[1]
          });
        }
      }
      setTitle(autoTitle);
    }
  }, [selectedUsers, t, title]);

  // Auto-génération de l'identifier depuis le titre
  useEffect(() => {
    if (conversationType !== 'direct' && title && title.trim()) {
      const generated = generateIdentifierFromTitle(title);
      setCustomIdentifier(generated);
    }
  }, [title, conversationType, generateIdentifierFromTitle]);

  // Auto-détection du type de conversation
  useEffect(() => {
    if (selectedUsers.length === 1) {
      if (conversationType !== 'group' && conversationType !== 'public') {
        setConversationType('direct');
      }
    } else if (selectedUsers.length > 1) {
      if (conversationType === 'direct') {
        setConversationType('group');
      }
    }
  }, [selectedUsers.length, conversationType]);

  // Gestion de la fermeture avec reset
  const handleClose = useCallback(() => {
    clearSelection();
    setSearchQuery('');
    setSelectedCommunity('');
    setCommunitySearchQuery('');
    setTitle('');
    setCustomIdentifier('');
    setConversationType('direct');
    setShowCommunitySection(false);
    setIsPreviewOpen(false);
    onClose();
  }, [clearSelection, onClose]);

  // Gestion de la création de conversation
  const handleCreateConversation = useCallback(async () => {
    const conversation = await createConversationFn({
      title,
      conversationType,
      selectedUsers,
      customIdentifier,
      selectedCommunity
    });

    if (conversation) {
      onConversationCreated(conversation.id, conversation);
      handleClose();
    }
  }, [
    title,
    conversationType,
    selectedUsers,
    customIdentifier,
    selectedCommunity,
    createConversationFn,
    onConversationCreated,
    handleClose
  ]);

  // Handler pour la sélection d'utilisateur avec clear du search
  const handleToggleUser = useCallback((user: User) => {
    toggleUserSelection(user);
    setSearchQuery('');
  }, [toggleUserSelection]);

  // Calcul de l'état de validation pour le bouton
  const isCreateDisabled =
    (conversationType !== 'public' && selectedUsers.length === 0) ||
    isCreating ||
    (conversationType !== 'direct' && !customIdentifier.trim()) ||
    (conversationType !== 'direct' && !validateIdentifierFormat(customIdentifier));

  // Helper pour les couleurs d'accent utilisateur
  const getUserAccentColor = (userId: string): string => {
    const colors = [
      'bg-blue-100 text-blue-800 border-blue-200',
      'bg-green-100 text-green-800 border-green-200',
      'bg-purple-100 text-purple-800 border-purple-200',
      'bg-pink-100 text-pink-800 border-pink-200',
      'bg-yellow-100 text-yellow-800 border-yellow-200',
      'bg-indigo-100 text-indigo-800 border-indigo-200',
      'bg-red-100 text-red-800 border-red-200',
      'bg-teal-100 text-teal-800 border-teal-200',
      'bg-orange-100 text-orange-800 border-orange-200',
      'bg-cyan-100 text-cyan-800 border-cyan-200'
    ];

    let hash = 0;
    for (let i = 0; i < userId.length; i++) {
      hash = userId.charCodeAt(i) + ((hash << 5) - hash);
    }
    return colors[Math.abs(hash) % colors.length];
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="max-w-3xl w-[95vw] max-h-[95vh] p-0 sm:max-w-3xl sm:w-[90vw] sm:max-h-[90vh] md:max-h-[85vh] flex flex-col dark:bg-gray-900 dark:border-gray-800">
        <DialogHeader className="px-4 pt-4 sm:px-6 sm:pt-6 pb-4 border-b dark:border-gray-800">
          <DialogTitle className="flex items-center gap-2 text-base sm:text-lg dark:text-gray-100">
            <Sparkles className="h-4 w-4 sm:h-5 sm:w-5 text-primary" aria-hidden="true" />
            {t('createConversationModal.title')}
          </DialogTitle>
          <DialogDescription className="dark:text-gray-400">
            {t('createConversationModal.description')}
          </DialogDescription>
        </DialogHeader>

        {/* Zone de contenu scrollable */}
        <div className="flex-1 overflow-y-auto px-4 sm:px-6 py-4 dark:bg-gray-900">
          <div className="space-y-6">
            {/* Étape 1: Sélection des membres */}
            <MemberSelectionStep
              searchQuery={searchQuery}
              onSearchChange={setSearchQuery}
              availableUsers={availableUsers}
              selectedUsers={selectedUsers}
              onToggleUser={handleToggleUser}
              isLoading={isLoading}
            />

            {/* Étape 2: Type de conversation */}
            <ConversationTypeStep
              conversationType={conversationType}
              onTypeChange={setConversationType}
              selectedUsersCount={selectedUsers.length}
            />

            {/* Étape 3: Détails de la conversation (titre et identifier) */}
            <ConversationDetailsStep
              title={title}
              customIdentifier={customIdentifier}
              conversationType={conversationType}
              onTitleChange={setTitle}
              onIdentifierChange={setCustomIdentifier}
              selectedUsers={selectedUsers}
              identifierAvailable={identifierAvailable}
              isCheckingIdentifier={isCheckingIdentifier}
              validateIdentifierFormat={validateIdentifierFormat}
            />

            {/* Étape 4: Sélection de communauté (optionnel) */}
            {(conversationType === 'group' || conversationType === 'public' || selectedUsers.length > 0) && (
              <CommunitySelectionStep
                showCommunitySection={showCommunitySection}
                onToggleSection={setShowCommunitySection}
                communities={communities}
                communitySearchQuery={communitySearchQuery}
                onSearchChange={setCommunitySearchQuery}
                selectedCommunity={selectedCommunity}
                onCommunitySelect={setSelectedCommunity}
                isLoadingCommunities={isLoadingCommunities}
              />
            )}

            {/* Aperçu - Accordéon */}
            {(conversationType === 'direct' || customIdentifier) && (
              <Collapsible
                open={isPreviewOpen}
                onOpenChange={setIsPreviewOpen}
                className="border rounded-lg"
              >
                <CollapsibleTrigger asChild>
                  <Button
                    variant="ghost"
                    className="w-full flex items-center justify-between p-4 hover:bg-muted/50 focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2"
                    aria-expanded={isPreviewOpen}
                  >
                    <div className="flex items-center gap-2">
                      <Sparkles className="h-4 w-4 text-primary" aria-hidden="true" />
                      <span className="font-medium">Récapitulatif de la conversation</span>
                    </div>
                    {isPreviewOpen ? (
                      <ChevronUp className="h-4 w-4" aria-hidden="true" />
                    ) : (
                      <ChevronDown className="h-4 w-4" aria-hidden="true" />
                    )}
                  </Button>
                </CollapsibleTrigger>
                <CollapsibleContent className="p-4 pt-0">
                  <ConversationPreview
                    title={title}
                    identifier={customIdentifier}
                    selectedUsers={selectedUsers}
                    selectedCommunity={selectedCommunity ? communities.find(c => c.id === selectedCommunity) : undefined}
                    conversationType={conversationType}
                    getUserAccentColor={getUserAccentColor}
                  />
                </CollapsibleContent>
              </Collapsible>
            )}
          </div>
        </div>

        {/* Footer avec actions fixes */}
        <div className="border-t bg-background dark:bg-gray-900 dark:border-gray-800 px-4 sm:px-6 py-4">
          <div className="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-3">
            <Button
              onClick={handleCreateConversation}
              disabled={isCreateDisabled}
              className="flex-1 w-full sm:w-auto text-xs sm:text-sm h-9 sm:h-11 focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2"
            >
              <Sparkles className="mr-1 sm:mr-2 h-3 w-3 sm:h-4 sm:w-4" aria-hidden="true" />
              {isCreating ? t('createConversationModal.actions.creating') :
                conversationType === 'direct' ? t('createConversationModal.actions.createDirectConversation') :
                conversationType === 'public' ? t('createConversationModal.actions.createPublicConversation') :
                t('createConversationModal.actions.createGroupConversation')}
            </Button>
            <Button
              onClick={handleClose}
              variant="outline"
              className="w-full sm:w-auto text-xs sm:text-sm h-9 sm:h-11 focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2"
            >
              {t('createConversationModal.actions.cancel')}
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}

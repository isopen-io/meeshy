/**
 * Unit tests for MetadataManager
 *
 * Tests metadata extraction for:
 * - Images: dimensions, thumbnails (sharp)
 * - Audio: duration, bitrate, codec (music-metadata)
 * - Video: dimensions, duration, fps, codec (fluent-ffmpeg)
 * - PDF: page count (pdf-parse)
 * - Text: line count
 *
 * @jest-environment node
 */

import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import type { Sharp } from 'sharp';
import type { IAudioMetadata } from 'music-metadata';
import type { FfprobeData, FfprobeStream } from 'fluent-ffmpeg';

// Mock dependencies
const mockSharp = jest.fn() as jest.MockedFunction<any>;
const mockParseFile = jest.fn() as jest.MockedFunction<any>;
const mockFfprobe = jest.fn() as jest.MockedFunction<any>;
const mockFsReadFile = jest.fn() as jest.MockedFunction<any>;
const mockFsStat = jest.fn() as jest.MockedFunction<any>;
const mockFsOpen = jest.fn() as jest.MockedFunction<any>;

// Mock Sharp chain
const createMockSharpChain = () => {
  const chain = {
    metadata: jest.fn() as any,
    resize: jest.fn() as any,
    jpeg: jest.fn() as any,
    toFile: jest.fn() as any,
    toBuffer: jest.fn() as any,
  };

  // Chain methods return the chain object for fluent API
  chain.resize.mockReturnValue(chain);
  chain.jpeg.mockReturnValue(chain);

  return chain;
};

// Mock PDFParse class
class MockPDFParse {
  private data: any;

  constructor(options: { data: Buffer }) {
    this.data = options.data;
  }

  async getInfo(): Promise<{ total: number }> {
    if (this.data.toString().includes('corrupted')) {
      throw new Error('Invalid PDF structure');
    }
    return { total: 5 };
  }

  async destroy(): Promise<void> {
    // Cleanup mock
  }
}

// Setup mocks
jest.mock('sharp', () => mockSharp);
jest.mock('music-metadata', () => ({
  parseFile: mockParseFile,
}));
jest.mock('fluent-ffmpeg', () => ({
  ffprobe: mockFfprobe,
}));
jest.mock('fs', () => ({
  promises: {
    readFile: mockFsReadFile,
  PDFParse: MockPDFParse,
}));

// Import after mocks
import { MetadataManager } from '../../../services/attachments/MetadataManager';
import type {
  AudioMetadata,
  VideoMetadata,
  ImageMetadata,
  PdfMetadata,
  TextMetadata,
} from '../../../services/attachments/MetadataManager';

describe('MetadataManager', () => {
  let metadataManager: MetadataManager;
  const uploadBasePath = '/test/uploads';

  beforeEach(() => {
    jest.clearAllMocks();
    metadataManager = new MetadataManager(uploadBasePath);

    // Setup default sharp chain
    const defaultChain = createMockSharpChain();
    mockSharp.mockReturnValue(defaultChain);
  });

  describe('Constructor', () => {
    it('should create instance with upload base path', () => {
      expect(metadataManager).toBeDefined();
      expect(metadataManager).toBeInstanceOf(MetadataManager);
    });
  });

  describe('extractImageMetadata', () => {
    it('should extract image dimensions from file path', async () => {
      const chain = createMockSharpChain();
      chain.metadata.mockResolvedValue({
        width: 1920,
        height: 1080,
        format: 'jpeg',
      });
      mockSharp.mockReturnValue(chain);

      const result = await metadataManager.extractImageMetadata('test/image.jpg');

      expect(mockSharp).toHaveBeenCalledWith('/test/uploads/test/image.jpg');
      expect(chain.metadata).toHaveBeenCalled();
      expect(result).toEqual({
        width: 1920,
        height: 1080,
      });
    });

    it('should handle missing dimensions', async () => {
      const chain = createMockSharpChain();
      chain.metadata.mockResolvedValue({
        format: 'jpeg',
        // Missing width and height
      });
      mockSharp.mockReturnValue(chain);

      const result = await metadataManager.extractImageMetadata('test/image.jpg');

      expect(result).toEqual({
        width: 0,
        height: 0,
      });
    });

    it('should handle errors and return default values', async () => {
      const chain = createMockSharpChain();
      chain.metadata.mockRejectedValue(new Error('Invalid image format'));
      mockSharp.mockReturnValue(chain);

      const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

      const result = await metadataManager.extractImageMetadata('test/corrupted.jpg');

      expect(result).toEqual({
        width: 0,
        height: 0,
      });
      expect(consoleSpy).toHaveBeenCalledWith(
        '[MetadataManager] Erreur extraction métadonnées image:',
        expect.any(Error)
      );

      consoleSpy.mockRestore();
    });

    it('should extract metadata from various image formats', async () => {
      const formats = [
        { path: 'test.jpg', width: 1920, height: 1080 },
        { path: 'test.png', width: 800, height: 600 },
        { path: 'test.webp', width: 1024, height: 768 },
      ];

      for (const format of formats) {
        const chain = createMockSharpChain();
        chain.metadata.mockResolvedValue({
          width: format.width,
          height: format.height,
        });
        mockSharp.mockReturnValue(chain);

        const result = await metadataManager.extractImageMetadata(format.path);

        expect(result).toEqual({
          width: format.width,
          height: format.height,
        });
      }
    });
  });

  describe('extractImageMetadataFromBuffer', () => {
    it('should extract image dimensions from buffer', async () => {
      const buffer = Buffer.from('fake image data');
      const chain = createMockSharpChain();
      chain.metadata.mockResolvedValue({
        width: 1280,
        height: 720,
      });
      mockSharp.mockReturnValue(chain);

      const result = await metadataManager.extractImageMetadataFromBuffer(buffer);

      expect(mockSharp).toHaveBeenCalledWith(buffer);
      expect(result).toEqual({
        width: 1280,
        height: 720,
      });
    });

    it('should handle buffer extraction errors', async () => {
      const buffer = Buffer.from('corrupted data');
      const chain = createMockSharpChain();
      chain.metadata.mockRejectedValue(new Error('Invalid buffer'));
      mockSharp.mockReturnValue(chain);

      const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

      const result = await metadataManager.extractImageMetadataFromBuffer(buffer);

      expect(result).toEqual({
        width: 0,
        height: 0,
      });

      consoleSpy.mockRestore();
    });
  });

  describe('generateThumbnail', () => {
    it('should generate thumbnail from image file', async () => {
      const chain = createMockSharpChain();
      chain.toFile.mockResolvedValue({ size: 12345 });
      mockSharp.mockReturnValue(chain);

      const result = await metadataManager.generateThumbnail('test/image.jpg');

      expect(mockSharp).toHaveBeenCalledWith('/test/uploads/test/image.jpg');
      expect(chain.resize).toHaveBeenCalledWith(300, 300, {
        fit: 'inside',
        withoutEnlargement: true,
      });
      expect(chain.jpeg).toHaveBeenCalledWith({ quality: 80 });
      expect(chain.toFile).toHaveBeenCalledWith('/test/uploads/test/image_thumb.jpg');
      expect(result).toBe('test/image_thumb.jpg');
    });

    it('should handle different image extensions', async () => {
      const chain = createMockSharpChain();
      chain.toFile.mockResolvedValue({ size: 12345 });
      mockSharp.mockReturnValue(chain);

      const result = await metadataManager.generateThumbnail('test/photo.png');

      expect(chain.toFile).toHaveBeenCalledWith('/test/uploads/test/photo_thumb.png');
      expect(result).toBe('test/photo_thumb.png');
    });

    it('should return null on thumbnail generation error', async () => {
      const chain = createMockSharpChain();
      chain.toFile.mockRejectedValue(new Error('Write error'));
      mockSharp.mockReturnValue(chain);

      const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

      const result = await metadataManager.generateThumbnail('test/image.jpg');

      expect(result).toBeNull();
      expect(consoleSpy).toHaveBeenCalled();

      consoleSpy.mockRestore();
    });
  });

  describe('generateThumbnailFromBuffer', () => {
    it('should generate thumbnail buffer from image buffer', async () => {
      const inputBuffer = Buffer.from('fake image');
      const outputBuffer = Buffer.from('thumbnail');

      const chain = createMockSharpChain();
      chain.toBuffer.mockResolvedValue(outputBuffer);
      mockSharp.mockReturnValue(chain);

      const result = await metadataManager.generateThumbnailFromBuffer(inputBuffer);

      expect(mockSharp).toHaveBeenCalledWith(inputBuffer);
      expect(chain.resize).toHaveBeenCalledWith(300, 300, {
        fit: 'inside',
        withoutEnlargement: true,
      });
      expect(chain.jpeg).toHaveBeenCalledWith({ quality: 80 });
      expect(result).toBe(outputBuffer);
    });

    it('should return undefined on buffer thumbnail error', async () => {
      const inputBuffer = Buffer.from('corrupted');
      const chain = createMockSharpChain();
      chain.toBuffer.mockRejectedValue(new Error('Processing error'));
      mockSharp.mockReturnValue(chain);

      const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});

      const result = await metadataManager.generateThumbnailFromBuffer(inputBuffer);

      expect(result).toBeUndefined();
      expect(consoleWarnSpy).toHaveBeenCalled();

      consoleWarnSpy.mockRestore();
    });
  });

  describe('extractAudioMetadata', () => {
    it('should extract audio metadata for MP3 file', async () => {
      const mockMetadata: Partial<IAudioMetadata> = {
        format: {
          duration: 180.5,
          bitrate: 192000,
          sampleRate: 44100,
          codec: 'MP3',
          numberOfChannels: 2,
        } as any,
      };

      mockParseFile.mockResolvedValue(mockMetadata);

      const result = await metadataManager.extractAudioMetadata('test/audio.mp3');

      expect(mockParseFile).toHaveBeenCalledWith('/test/uploads/test/audio.mp3');
      expect(result).toEqual({
        duration: 181, // Rounded
        bitrate: 192000,
        sampleRate: 44100,
        codec: 'MP3',
        channels: 2,
      });
    });

    it('should extract audio metadata for WebM file', async () => {
      const mockMetadata: Partial<IAudioMetadata> = {
        format: {
          duration: 60.2,
          bitrate: 128000,
          sampleRate: 48000,
          codec: 'opus',
          numberOfChannels: 1,
        } as any,
      };

      mockParseFile.mockResolvedValue(mockMetadata);

      const result = await metadataManager.extractAudioMetadata('test/voice.webm');

      expect(result).toEqual({
        duration: 60,
        bitrate: 128000,
        sampleRate: 48000,
        codec: 'opus',
        channels: 1,
      });
    });

    it('should use codecProfile when codec is not available', async () => {
      const mockMetadata: Partial<IAudioMetadata> = {
        format: {
          duration: 120,
          codecProfile: 'AAC LC',
          numberOfChannels: 2,
        } as any,
      };

      mockParseFile.mockResolvedValue(mockMetadata);

      const result = await metadataManager.extractAudioMetadata('test/audio.m4a');

      expect(result.codec).toBe('AAC LC');
    });

    it('should handle missing optional fields', async () => {
      const mockMetadata: Partial<IAudioMetadata> = {
        format: {
          // Only minimal data
        } as any,
      };

      mockParseFile.mockResolvedValue(mockMetadata);

      const result = await metadataManager.extractAudioMetadata('test/audio.wav');

      expect(result).toEqual({
        duration: 0,
        bitrate: 0,
        sampleRate: 0,
        codec: 'unknown',
        channels: 1,
      });
    });

    it('should handle audio extraction errors', async () => {
      mockParseFile.mockRejectedValue(new Error('Unsupported format'));

      const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

      const result = await metadataManager.extractAudioMetadata('test/corrupted.mp3');

      expect(result).toEqual({
        duration: 0,
        bitrate: 0,
        sampleRate: 0,
        codec: 'unknown',
        channels: 1,
      });
      expect(consoleSpy).toHaveBeenCalledWith(
        '[MetadataManager] Erreur extraction métadonnées audio:',
        expect.objectContaining({
          filePath: 'test/corrupted.mp3',
        })
      );

      consoleSpy.mockRestore();
    });
  });

  describe('extractVideoMetadata', () => {
    it('should extract video metadata with ffprobe', async () => {
      const mockFfprobeData: Partial<FfprobeData> = {
        streams: [
          {
            codec_type: 'video',
            codec_name: 'h264',
            width: 1920,
            height: 1080,
            r_frame_rate: '30/1',
          } as FfprobeStream,
        ],
        format: {
          duration: 120.5,
          bit_rate: '5000000',
        } as any,
      };

      mockFfprobe.mockImplementation((path: string, callback: Function) => {
        callback(null, mockFfprobeData);
      });

      const result = await metadataManager.extractVideoMetadata('test/video.mp4');

      expect(mockFfprobe).toHaveBeenCalledWith(
        '/test/uploads/test/video.mp4',
        expect.any(Function)
      );
      expect(result).toEqual({
        duration: 121, // Rounded
        width: 1920,
        height: 1080,
        fps: 30,
        videoCodec: 'h264',
        bitrate: 5000000,
      });
    });

    it('should calculate fps from frame rate fraction', async () => {
      const mockFfprobeData: Partial<FfprobeData> = {
        streams: [
          {
            codec_type: 'video',
            r_frame_rate: '24000/1001', // 23.976 fps
          } as FfprobeStream,
        ],
        format: {} as any,
      };

      mockFfprobe.mockImplementation((path: string, callback: Function) => {
        callback(null, mockFfprobeData);
      });

      const result = await metadataManager.extractVideoMetadata('test/video.mp4');

      expect(result.fps).toBeCloseTo(23.98, 1);
    });

    it('should handle video without video stream', async () => {
      const mockFfprobeData: Partial<FfprobeData> = {
        streams: [
          {
            codec_type: 'audio', // No video stream
          } as FfprobeStream,
        ],
        format: {} as any,
      };

      mockFfprobe.mockImplementation((path: string, callback: Function) => {
        callback(null, mockFfprobeData);
      });

      const result = await metadataManager.extractVideoMetadata('test/audio-only.mp4');

      expect(result).toEqual({
        duration: 0,
        width: 0,
        height: 0,
        fps: 0,
        videoCodec: 'unknown',
        bitrate: 0,
      });
    });

    it('should handle ffprobe errors', async () => {
      mockFfprobe.mockImplementation((path: string, callback: Function) => {
        callback(new Error('ffprobe error'));
      });

      await expect(
        metadataManager.extractVideoMetadata('test/corrupted.mp4')
      ).rejects.toThrow('ffprobe error');
    });

    it('should timeout after 30 seconds', async () => {
      jest.useFakeTimers();

      mockFfprobe.mockImplementation((path: string, callback: Function) => {
        // Never call callback - simulate hang
      });

      const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});

      const promise = metadataManager.extractVideoMetadata('test/hanging.mp4');

      // Fast-forward time
      jest.advanceTimersByTime(30000);

      await expect(promise).rejects.toThrow('ffprobe timeout after 30 seconds');
      expect(consoleWarnSpy).toHaveBeenCalledWith(
        '[MetadataManager] Timeout ffprobe pour:',
        'test/hanging.mp4'
      );

      consoleWarnSpy.mockRestore();
      jest.useRealTimers();
    });

    it('should extract metadata from different video codecs', async () => {
      const codecs = ['h264', 'vp8', 'vp9', 'av1'];

      for (const codec of codecs) {
        const mockFfprobeData: Partial<FfprobeData> = {
          streams: [
            {
              codec_type: 'video',
              codec_name: codec,
              width: 1280,
              height: 720,
            } as FfprobeStream,
          ],
          format: {} as any,
        };

        mockFfprobe.mockImplementation((path: string, callback: Function) => {
          callback(null, mockFfprobeData);
        });

        const result = await metadataManager.extractVideoMetadata(`test/video.${codec}`);

        expect(result.videoCodec).toBe(codec);
      }
    });
  });

  describe('extractPdfMetadata', () => {
    it('should extract PDF page count', async () => {
      const pdfBuffer = Buffer.from('valid pdf content');
      mockFsReadFile.mockResolvedValue(pdfBuffer);

      const result = await metadataManager.extractPdfMetadata('test/document.pdf');

      expect(mockFsReadFile).toHaveBeenCalledWith('/test/uploads/test/document.pdf');
      expect(result).toEqual({
        pageCount: 5,
      });
    });

    it('should handle corrupted PDF files', async () => {
      const pdfBuffer = Buffer.from('corrupted pdf');
      mockFsReadFile.mockResolvedValue(pdfBuffer);

      const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

      const result = await metadataManager.extractPdfMetadata('test/corrupted.pdf');

      expect(result).toEqual({
        pageCount: 0,
      });
      expect(consoleSpy).toHaveBeenCalled();

      consoleSpy.mockRestore();
    });

    it('should handle file read errors', async () => {
      mockFsReadFile.mockRejectedValue(new Error('File not found'));

      const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

      const result = await metadataManager.extractPdfMetadata('test/missing.pdf');

      expect(result).toEqual({
        pageCount: 0,
      });

      consoleSpy.mockRestore();
    });
  });

  describe('extractTextMetadata', () => {
    it('should count lines in text file', async () => {
      const content = 'Line 1\nLine 2\nLine 3\nLine 4\nLine 5';
      mockFsReadFile.mockResolvedValue(content);

      const result = await metadataManager.extractTextMetadata('test/file.txt');

      expect(mockFsReadFile).toHaveBeenCalledWith(
        '/test/uploads/test/file.txt',
        'utf-8'
      );
      expect(result).toEqual({
        lineCount: 5,
      });
    });

    it('should handle empty files', async () => {
      mockFsReadFile.mockResolvedValue('');

      const result = await metadataManager.extractTextMetadata('test/empty.txt');

      expect(result).toEqual({
        lineCount: 1, // Empty string split gives 1 element
      });
    });

    it('should handle files with various line endings', async () => {
      const content = 'Line 1\r\nLine 2\rLine 3\nLine 4';
      mockFsReadFile.mockResolvedValue(content);

      const result = await metadataManager.extractTextMetadata('test/mixed.txt');

      // Counts \n characters
      expect(result.lineCount).toBeGreaterThan(0);
    });

    it('should handle text extraction errors', async () => {
      mockFsReadFile.mockRejectedValue(new Error('Read error'));

      const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

      const result = await metadataManager.extractTextMetadata('test/error.txt');

      expect(result).toEqual({
        lineCount: 0,
      });
      expect(consoleSpy).toHaveBeenCalled();

      consoleSpy.mockRestore();
    });
  });

  describe('extractMetadata - Main orchestrator', () => {
    it('should extract metadata for image type', async () => {
      const chain = createMockSharpChain();
      chain.metadata.mockResolvedValue({
        width: 1920,
        height: 1080,
      });
      mockSharp.mockReturnValue(chain);

      const result = await metadataManager.extractMetadata(
        'test/image.jpg',
        'image',
        'image/jpeg'
      );

      expect(result).toEqual({
        width: 1920,
        height: 1080,
      });
    });

    it('should extract metadata for audio type with provided metadata', async () => {
      const providedMetadata = {
        duration: 120.5,
        bitrate: 192000,
        sampleRate: 44100,
        codec: 'opus',
        channels: 2,
        audioEffectsTimeline: [{ type: 'fade', start: 0, end: 1000 }],
      };

      const result = await metadataManager.extractMetadata(
        'test/audio.webm',
        'audio',
        'audio/webm',
        providedMetadata
      );

      expect(result).toEqual({
        duration: 121, // Rounded
        bitrate: 192000,
        sampleRate: 44100,
        codec: 'opus',
        channels: 2,
        audioEffectsTimeline: [{ type: 'fade', start: 0, end: 1000 }],
      });

      // Should NOT call extractAudioMetadata when metadata is provided
      expect(mockParseFile).not.toHaveBeenCalled();
    });

    it('should extract metadata for audio type without provided metadata', async () => {
      const mockMetadata: Partial<IAudioMetadata> = {
        format: {
          duration: 60,
          bitrate: 128000,
          sampleRate: 48000,
          codec: 'MP3',
          numberOfChannels: 2,
        } as any,
      };

      mockParseFile.mockResolvedValue(mockMetadata);

      const result = await metadataManager.extractMetadata(
        'test/audio.mp3',
        'audio',
        'audio/mpeg'
      );

      expect(mockParseFile).toHaveBeenCalled();
      expect(result).toEqual({
        duration: 60,
        bitrate: 128000,
        sampleRate: 48000,
        codec: 'MP3',
        channels: 2,
      });
    });

    it('should extract metadata for video type', async () => {
      const mockFfprobeData: Partial<FfprobeData> = {
        streams: [
          {
            codec_type: 'video',
            codec_name: 'h264',
            width: 1280,
            height: 720,
            r_frame_rate: '30/1',
          } as FfprobeStream,
        ],
        format: {
          duration: 90,
          bit_rate: '3000000',
        } as any,
      };

      mockFfprobe.mockImplementation((path: string, callback: Function) => {
        callback(null, mockFfprobeData);
      });

      const result = await metadataManager.extractMetadata(
        'test/video.mp4',
        'video',
        'video/mp4'
      );

      expect(result).toEqual({
        duration: 90,
        width: 1280,
        height: 720,
        fps: 30,
        videoCodec: 'h264',
        bitrate: 3000000,
      });
    });

    it('should handle video extraction errors gracefully', async () => {
      mockFfprobe.mockImplementation((path: string, callback: Function) => {
        callback(new Error('ffprobe failed'));
      });

      const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});

      const result = await metadataManager.extractMetadata(
        'test/video.mp4',
        'video',
        'video/mp4'
      );

      expect(result).toEqual({
        duration: 0,
        width: 0,
        height: 0,
        fps: 0,
        videoCodec: 'unknown',
        bitrate: 0,
      });
      expect(consoleWarnSpy).toHaveBeenCalledWith(
        "[MetadataManager] Impossible d'extraire métadonnées vidéo:",
        expect.any(Error)
      );

      consoleWarnSpy.mockRestore();
    });

    it('should extract metadata for PDF documents', async () => {
      const pdfBuffer = Buffer.from('valid pdf');
      mockFsReadFile.mockResolvedValue(pdfBuffer);

      const result = await metadataManager.extractMetadata(
        'test/document.pdf',
        'document',
        'application/pdf'
      );

      expect(result).toEqual({
        pageCount: 5,
      });
    });

    it('should not extract metadata for non-PDF documents', async () => {
      const result = await metadataManager.extractMetadata(
        'test/document.docx',
        'document',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
      );

      expect(result).toEqual({});
      expect(mockFsReadFile).not.toHaveBeenCalled();
    });

    it('should extract metadata for text type', async () => {
      const content = 'Line 1\nLine 2\nLine 3';
      mockFsReadFile.mockResolvedValue(content);

      const result = await metadataManager.extractMetadata(
        'test/file.txt',
        'text',
        'text/plain'
      );

      expect(result).toEqual({
        lineCount: 3,
      });
    });

    it('should extract metadata for code type', async () => {
      const content = 'function test() {\n  return true;\n}';
      mockFsReadFile.mockResolvedValue(content);

      const result = await metadataManager.extractMetadata(
        'test/script.js',
        'code',
        'application/javascript'
      );

      expect(result).toEqual({
        lineCount: 3,
      });
    });

    it('should return empty metadata for unsupported types', async () => {
      const result = await metadataManager.extractMetadata(
        'test/unknown.bin',
        'binary',
        'application/octet-stream'
      );

      expect(result).toEqual({});
    });

    it('should handle multiple metadata extractions in sequence', async () => {
      // Image
      const imageChain = createMockSharpChain();
      imageChain.metadata.mockResolvedValue({ width: 800, height: 600 });
      mockSharp.mockReturnValue(imageChain);

      const imageResult = await metadataManager.extractMetadata(
        'test/img.jpg',
        'image',
        'image/jpeg'
      );

      expect(imageResult).toEqual({ width: 800, height: 600 });

      // Text
      mockFsReadFile.mockResolvedValue('Line 1\nLine 2');

      const textResult = await metadataManager.extractMetadata(
        'test/file.txt',
        'text',
        'text/plain'
      );

      expect(textResult).toEqual({ lineCount: 2 });

      // Both should succeed independently
      expect(imageResult).toBeDefined();
      expect(textResult).toBeDefined();
    });
  });

  describe('Edge Cases and Error Handling', () => {
    it('should handle very large image dimensions', async () => {
      const chain = createMockSharpChain();
      chain.metadata.mockResolvedValue({
        width: 10000,
        height: 10000,
      });
      mockSharp.mockReturnValue(chain);

      const result = await metadataManager.extractImageMetadata('test/huge.jpg');

      expect(result.width).toBe(10000);
      expect(result.height).toBe(10000);
    });

    it('should handle very long audio files', async () => {
      const mockMetadata: Partial<IAudioMetadata> = {
        format: {
          duration: 10800, // 3 hours
          bitrate: 320000,
          sampleRate: 48000,
          codec: 'AAC',
          numberOfChannels: 2,
        } as any,
      };

      mockParseFile.mockResolvedValue(mockMetadata);

      const result = await metadataManager.extractAudioMetadata('test/long-audio.m4a');

      expect(result.duration).toBe(10800);
    });

    it('should handle files with special characters in path', async () => {
      const chain = createMockSharpChain();
      chain.metadata.mockResolvedValue({ width: 1920, height: 1080 });
      mockSharp.mockReturnValue(chain);

      const result = await metadataManager.extractImageMetadata(
        'test/special chars & spaces.jpg'
      );

      expect(mockSharp).toHaveBeenCalledWith(
        '/test/uploads/test/special chars & spaces.jpg'
      );
      expect(result.width).toBe(1920);
    });

    it('should handle concurrent metadata extractions', async () => {
      const chain1 = createMockSharpChain();
      chain1.metadata.mockResolvedValue({ width: 1920, height: 1080 });

      const chain2 = createMockSharpChain();
      chain2.metadata.mockResolvedValue({ width: 800, height: 600 });

      mockSharp.mockReturnValueOnce(chain1).mockReturnValueOnce(chain2);

      const [result1, result2] = await Promise.all([
        metadataManager.extractImageMetadata('test/img1.jpg'),
        metadataManager.extractImageMetadata('test/img2.jpg'),
      ]);

      expect(result1).toEqual({ width: 1920, height: 1080 });
      expect(result2).toEqual({ width: 800, height: 600 });
    });
  });
});

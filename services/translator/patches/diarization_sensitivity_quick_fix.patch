--- a/services/translator/src/services/diarization_speechbrain.py
+++ b/services/translator/src/services/diarization_speechbrain.py
@@ -254,7 +254,8 @@ class SpeechBrainDiarization:
     async def diarize(
         self,
         audio_path: str,
         window_size_ms: int = 1500,  # FenÃªtre de 1.5s
         hop_size_ms: int = 750,       # Hop de 0.75s (50% overlap)
-        max_speakers: int = 5
+        max_speakers: int = 2,        # âœ… RÃ‰DUIT: 5 â†’ 2 (moins sensible)
+        num_speakers: Optional[int] = None  # âœ… NOUVEAU: Forcer nombre exact
     ) -> DiarizationResult:
         """
@@ -315,7 +316,7 @@ class SpeechBrainDiarization:
         if len(embeddings) >= 4:  # Minimum pour clustering
             # Limiter le nombre max de clusters testÃ©s
-            max_clusters_to_test = min(max_speakers + 1, len(embeddings) // 3, 4)
+            max_clusters_to_test = min(max_speakers + 1, len(embeddings) // 3, 3)  # âœ… RÃ‰DUIT: 4 â†’ 3

             for n in range(2, max_clusters_to_test):
                 clustering = AgglomerativeClustering(
@@ -329,8 +330,8 @@ class SpeechBrainDiarization:

                 logger.info(f"[SPEECHBRAIN]    Test n={n} clusters: score={score:.3f}")

-                # Seuil de 0.25 : acceptable pour voix humaines rÃ©elles
-                # Score silhouette : >0.7=excellent, 0.5-0.7=bon, 0.25-0.5=acceptable, <0.25=faible
-                if score > best_score and score > 0.25:  # Seuil rÃ©aliste pour voix humaines
+                # âœ… AUGMENTÃ‰: 0.25 â†’ 0.35 (seuil plus strict, moins de faux positifs)
+                # Score silhouette : >0.7=excellent, 0.5-0.7=bon, 0.35-0.5=acceptable, <0.35=faible
+                if score > best_score and score > 0.35:  # Seuil strict pour Ã©viter sur-segmentation
                     best_score = score
                     best_n_clusters = n

--- a/services/translator/src/services/diarization_service.py
+++ b/services/translator/src/services/diarization_service.py
@@ -189,7 +189,11 @@ class DiarizationService:
         logger.info("[DIARIZATION] ðŸŽ¯ DÃ©tection avec pyannote.audio")

         try:
             # ExÃ©cuter la diarisation
-            diarization = pipeline(audio_path)
+            # âœ… NOUVEAU: ParamÃ¨tres min/max speakers pour rÃ©duire sensibilitÃ©
+            diarization = pipeline(
+                audio_path,
+                min_speakers=1,        # âœ… Accepter 1 seul speaker
+                max_speakers=2         # âœ… Limiter Ã  2 (au lieu de dÃ©tection libre)
+            )

             # Parser les rÃ©sultats
             speakers_data = {}
